% !TEX encoding = UTF-8 Unicode

% example for dissertation.sty
\documentclass[
  % Replace oneside by twoside if you are printing your thesis on both sides
  % of the paper, leave as is for single sided prints or for viewing on screen.
  oneside,
  %twoside,
  10pt, a4paper,
  footinclude=true,
  headinclude=true,
  cleardoublepage=empty
]{scrbook}



\usepackage{dissertation}

% ----------------------------------------------------------------

% Title
\titleA{Sistemas de Representação}
\titleB{de Conhecimento e Raciocínio}

\subtitleA{Exercício 2} % (if any)
\subtitleB{Grupo 1}

% Author
\author{Filipe C. Oliveira, Filipe S. Marques, Luís F. Mendes}


% University (uncomment if you need to change default values)
% \def\school{Escola de Engenharia}
% \def\department{Departamento de Inform\'{a}tica}
% \def\university{Universidade do Minho}
% \def\masterdegree{Computer Science}

% Date
\date{\myear} % change to text if date is not today

% Keywords
%\keywords{master thesis}

% Glossaries & Acronyms
%\makeglossaries  %  either use this ...
%\makeindex	   % ... or this

% Define Acronyms
%\input{sec/acronyms}
%\glsaddall[types={\acronymtype}]


\ummetadata % add metadata to the document (author, publisher, ...)

\begin{document}
	% Cover page ---------------------------------------
	\umfrontcover	
	\umtitlepage
	
	% Add acknowledgements ----------------------------
	
	\cleardoublepage
	%\chapter*{Resumo}
	%Escrever aqui resumo (pt) ou importar respectivo ficheiro
	
	
	% Summary Lists ------------------------------------
	\tableofcontents
	%\listoffigures
	%\listoftables
	%\lstlistoflistings
	%\listofabbreviations
	
	
	\pagenumbering{arabic}
	
	% CHAPTER - Introduction -------------------------
	\chapter{Introdução}
		A componente prática da unidade curricular de Sistemas de Representação de Conhecimento e Raciocínio, inserida no 3º ano do plano curricular do Mestrado  Integrado em Engenharia Informática, pressupõem a realização de trabalhos de grupo na forma de um conjunto de exercícios. Este será portanto o segundo dos exercícios práticos, tendo por principal tema a programação em lógica estendida em PROLOG e o conceito de invariantes, no âmbito da representação de conhecimento imperfeito, recorrendo à utilização de valores nulos, e construção de mecanismos de raciocínio, por forma a caracterizar um universo de discurso com o qual se pretende abordar a temática do registo de eventos numa instituição de saúde. \par 
Pretende-se \textbf{assumir a possibilidade da existência de informação válida que não está representada no sistema de representação de conhecimento}, baseando o sistema nos seguintes pressupostos\footnote{em "Representação de Informação Incompleta", por 
Cesar Analide  e José Neves}:
\begin{itemize}
\item - \textbf{Pressuposto do Mundo Aberto} – podem existir outros factos ou conclusões verdadeiros para além daqueles representados na base de
conhecimento;
\item \textbf{Pressuposto dos Nomes Únicos} – duas constantes diferentes (que definam valores atómicos ou objectos) designam, necessariamente, duas
entidades diferentes do universo de discurso;
\item \textbf{Pressuposto do Domínio Aberto} – podem existir mais objectos do universo de discurso para além daqueles designados pelas constantes da base
de conhecimento.
\end{itemize}


Todo o trabalho prático será realizado no sentido de dotar um sistema de representação de conhecimento de características capazes de o fazer raciocinar segundo estes três pressupostos.\par 

Para o efeito, foi desenvolvido um exemplo prático elucidativo deste panorama, incluindo a identificação simplista dos serviços, utentes, e registos de consultas médicas. Foram ainda apresentadas um conjunto de funcionalidades mínimas, as quais foram devidamente cumpridas, ressalvando-se ainda a adição de funcionalidades extra que o grupo julgou serem relevantes para exemplo prático.\par 
A interação com o sistema criado para a implementação do caso prático foi desenvolvida em JAVA, com recurso á biblioteca JASPER.


	% CHAPTER - Problem and Challenges ---------------
	\chapter{Caracterização do Problema}
	         A elaboração do caso prático anteriormente descrito tinha como funcionalidades obrigatórias:
	         
\label{objectivos}
\begin{itemize}
\item 1) Representar conhecimento positivo e negativo;
\item 2) Representar casos de conhecimento imperfeito, pela utilização de valores nulos possibilitando assim representar conhecimento imperfeito incerto, conhecimento imperfeito impreciso, e conhecimento imperfeito interdito;
\item 3 ) Manipular invariantes que designem restrições à inserção e à remoção de conhecimento do sistema;
\item 4) Lidar com a problemática da evolução do conhecimento, criando os procedimentos adequados;
\item 5) Desenvolver um sistema de inferência capaz de implementar os mecanismos de raciocínio inerentes a estes sistemas;
\end{itemize}
\vspace{1cm}

Sabendo que o conhecimento é caracterizado da seguinte forma:
\begin{itemize}
\item{utente: \#IdUt, Nome, Idade, Morada \rightarrow $\{V,F,D\}$
}

\item{serviço: \#IdServ, Descrição, Instituição, Cidade \rightarrow $\{V,F,D\}$
}

\item consulta: Data, \#IdUt, \#IdServ, Custo \rightarrow $\{V,F,D\}$

\end{itemize}
\vspace{1cm}

Por forma a demonstrar as funcionalidades anteriormente enumeradas será permitido no nosso caso prático:
\begin{itemize}
\item E1) Identificar todas as consultas médicas de um utente;
\item E2) Calcular o custo de todas as consultas médicas de um utente;
\item E3) Determinar todos os utentes que recorreram a um serviço;
\item E4) Identificar os serviços que se podem encontrar numa instituição;
\item E5) Registar utentes, serviços, ou consultas no sistema;
\item E6) Remover utentes, ou serviços, ou consultas do sistema;
\end{itemize}


Ora, associando às funcionalidades descritas o tipo de conhecimento envolvido para a sua resolução obtemos:

\begin{itemize}
\item E1) Identificar todas as consultas médicas de um utente: \textbf{\{Consulta\}};
\item E2) Calcular o custo de todas as consultas médicas de um utente: \textbf{\{Utente, Consulta\}};
\item E3) Determinar todos os utentes que recorreram a um serviço: \textbf{\{Utente, Serviço\}};
\item E4) Identificar os serviços que se podem encontrar numa instituição: \textbf{\{Serviço\}};
\item E5) Registar utentes, serviços, ou consultas no sistema: \textbf{\{Utente, Serviço, Consulta\}};
\item E6) Remover utentes, ou serviços, ou consultas do sistema: \textbf{\{Utente, Serviço, Consulta\}};
\end{itemize}



\chapter{Solução Proposta}

Sabemos agora quais as entidades que teremos que relacionar para a resolução de cada funcionalidade. Resta-nos portanto indicar qual o conhecimento necessário a cada entidade (\textbf{Utente, Serviço, Consulta Médica}).\par 
Denote que para todas as entidades do caso prático, foram criadas situações em que não existe informação completa acerca do problema em equação.

    \section{Entidades}
        \subsection{Utente}
        A informação lógica relevante relativa ao utente, para o nosso exemplo prático, é o seu identificador único, o nome do utente, a idade, e morada. Denote que, tal com enumerado anteriormente, cada utente tem um identificador único, não sendo permitidos dois utentes com identificadores iguais, como formularemos logicamente nas secções \ref{invariantes_adicao} e \ref{invariantes_remocao}, que lidam com a problemática da evolução do conhecimento, manipulando invariantes para as operações de adição e remoção respetivamente.\par 
        De seguida passaremos a especificar e justificar a extensão do predicado utente, enumerando situações que exemplificam conhecimento positivo e negativo, e casos de conhecimento imperfeito.\par 
        
        \subsubsection{\textbf{Extensão do predicado utente:}}
        
        A descrição informal do conhecimento sobre utentes pode ser representada através de Programação Lógica Estendida, pela introdução do predicado utente com quatro argumentos. O primeiro representa o identificador único do utente, o segundo representa o nome do utente, o terceiro representa a idade, e o quarto representa a morada.\par 
        
Para representar corretamente esta informação, \textbf{incluindo situações de exceção}, torna-se necessária uma formalização adequada  numa linguagem que permita tratar valores nulos. \par
Precisamos ainda de fazer uso da \texbf{negação explícita (em conjunto com a implícita)}, para formalizar a descrição de informação.\par 
Temos assim a possibilidade de representar situações de conhecimento perfeito positivo e negativo, incluindo ainda situações de exceção que iremos discutir posteriormente. Atente na transposição para PLE:\par 
\subsubsection{\textbf{Situações de conhecimento perfeito positivo e negativo:}}
\label{pred_utente}
\begin{lstlisting}
 % Extensao do predicado utente: IdUt, Nome, Idade, Morada -> {V,F,D}
 
 -utente(IdUt, Nome, Idade, Morada) :- nao(utente(IdUt, Nome, Idade, Morada)),
                                       nao(excecao(utente(IdUt, Nome, Idade, Morada))).
\end{lstlisting}

Assim, os enunciados: 
\begin{itemize}
\item i) Utente com identificador único ut001, nome António Sousa, idade 24 anos, e residente na Rua de Santo Ovídio.
\item ii) Utente com identificador único ut002, nome Filipe Oliveira, idade 25 anos, e residente na Urbanização Quinta dos Órfãos.
\item iii) Utente com identificador único ut003, nome Fernando Oliveira, idade 55 anos, e residente na rua General Humberto Delgado.
\end{itemize}

seriam traduzidos logicamente  no nosso exemplo prático em:
\begin{lstlisting}
utente(ut001,antonio_sousa,24,rua_de_santo_ovidio).
utente(ut002,filipe_oliveira,25,urb_qta_orfaos).
utente(ut003,fernando_oliveira,55,rua_gen_humberto_delgado).
\end{lstlisting}

%%%%%%%%%%%%
% INCERTO
%%%%%%%%%%%%

\subsubsection{\textbf{Situações de conhecimento imperfeito incerto:}}

Por forma a representarmos conhecimento \textbf{imperfeito incerto}, identificam-se situações anómalas à informação negativa via \textbf{exceções}.\par 
Nestas expressões, considerando X como uma sequência de variáveis $X_{1}$,$X_{2}$, ...,$X_{n}$, em que n é o número de argumentos do predicado \textbf{utente}, então $v_{i}$ representa a mesma sequência , mas na qual se substitui $X_{j}$ pelo valor nulo específico v.\par No caso do predicado utente, foi incluído no corpo da formalização lógica a exceção, tal como visto anteriormente na secção \ref{pred_utente}.\par 

Assim, os enunciados: 
\begin{itemize}
\item i) O utente Filipe Marques, de código ut006, residente na Rua de Santo Ovídio, tem idade desconhecida no momento.
\item ii) O utente Sérgio Caldas, de código ut007, de idade 25 anos, tem residência desconhecida no momento.
\end{itemize}

seriam traduzidos logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 utente(ut006,filipe_marques,imperfeito_incerto1,rua_santo_ovidio).
 utente(ut007,sergio_caldas,25,imperfeito_incerto2).
 
 excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, imperfeito_incerto1, Morada).
 excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, Idade, imperfeito_incerto2).
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito impreciso:}}


        
        %%%%%%%%%%%%
        % IMPRECISO
        %%%%%%%%%%%%
        
Valores nulos do tipo imperfeito impreciso, representam-se, tal como para situações de conhecimento imperfeito incerto, via \textbf{exceções}. Contudo, neste caso os valores atómicos nulos específicos concretizam explicitamente todas as possibilidades de representação dos valores nulos. Neste caso restringimos as situações de desconhecimento de informação.\par 


Assim, o enunciado: 
\begin{itemize}
\item i) Sabe-se que o utente Luís Mendes, de código ut008, tem idade entre 25 e 30 anos, e residência na Rua das Margaridas.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 excecao(utente(ut008, luis_mendes, IDADE, rua_das_margaridas)) :- IDADE =< 30, IDADE >=25.
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito interdito:}}

        %%%%%%%%%%%%
        % INTERDITO
        %%%%%%%%%%%%
Tal como verificado nas subsecções anteriores, representa-se um valor nulo $n_{i}$ do tipo não permitido via \textbf{exceções}. Nestes casos temos ainda a necessidade de garantir a não permissão de qualquer atualização a este tipo de valores, explicitando o valor nulo,
a confirmar pela aplicação de uma restrição adequadamente construída para o efeito, impedindo a posterior inclusão de valores atómicos que violem a condição imposta pelo valor nulo não permitido.


Assim, o enunciado: 
\begin{itemize}
\item i) O utente Carlos Sá, de código ut009, mudo, sem documentos, e incapacitado foi encontrado na rua, passando a residir na fundação abcd, pelo que se torna impossível vir a saber a idade do mesmo.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:


\begin{lstlisting}
 utente(ut009, carlos_sa, imperfeito_interdito1, fundacao_abcd).
 excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, imperfeito_interdito1, Morada).
 
 nulo(imperfeito_interdito1).

+utente(IdUt,Nome,Idade,Morada)::(
   solucoes( (IdUt,Nome,Idade,Morada), ( utente(ut009,carlos_sa,Idade,fundacao_abcd),nao(nulo(Idade))),S),
   comprimento(S,N),
   N==0
 ).
 \end{lstlisting}


        
         
         
         

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
           %%%%%%%%%%%%%%%%%
         %%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%
       %%%%%
       %%%%%
       %%%%%  SERVIÇO
       %%%%%
       %%%%%
    %%%%%%%%%%%    
    %%%%%%%%%%%    
        %%%%
        %%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%
        
      \subsection{Serviço}
        A informação lógica relevante relativa aos serviços médicos, para o nosso exemplo prático, é o seu identificador único, a descrição do mesmo, a instituição onde este está inserido, assim como a cidade. Denote que, tal com enumerado anteriormente, cada serviço tem um identificador único, não sendo permitidos dois serviços com identificadores iguais, como formularemos logicamente nas secções \ref{invariantes_adicao} e \ref{invariantes_remocao}, que lidam com a problemática da evolução do conhecimento, manipulando invariantes para as operações de adição e remoção respetivamente.\par 
        De seguida passaremos a especificar e justificar a extensão do predicado serviço, enumerando situações que exemplificam conhecimento positivo e negativo, e casos de conhecimento imperfeito.\par 
        
        \subsubsection{\textbf{Extensão do predicado servico:}}
        
        A descrição informal do conhecimento sobre serviços médicos pode ser representada através de Programação Lógica Estendida, pela introdução do predicado servico com quatro argumentos. O primeiro representa o identificador único do serviço, o segundo representa a descrição do mesmo, o terceiro representa a instituição onde este se insere, e o quarto representa a cidade onde este se localiza.\par 
        
Para representar corretamente esta informação, \textbf{incluindo situações de exceção}, torna-se necessária uma formalização adequada  numa linguagem que permita tratar valores nulos. \par
Precisamos ainda de fazer uso da \texbf{negação explícita (em conjunto com a implícita)}, para formalizar a descrição de informação.\par 
Temos assim a possibilidade de representar situações de conhecimento perfeito positivo e negativo, incluindo ainda situações de exceção que iremos discutir posteriormente. Atente na transposição para PLE:\par 
\subsubsection{\textbf{Situações de conhecimento perfeito positivo e negativo:}}
\label{pred_servico}
\begin{lstlisting}
  % Extensao do predicado servico: IdServ, Descricao, Instituicao, Cidade -> {V,F,D}
 
 -servico(IdServ, Descricao, Instituicao, Cidade) :- nao(servico(IdServ, Descricao, Instituicao, Cidade)),
                                                     nao(excecao(servico(IdServ, Descricao, Instituicao, Cidade))).
\end{lstlisting}

Assim, os enunciados: 
\begin{itemize}
\item i) Serviço código sv001, descrição "Cardiologia", na instituição Hospital de Viana do Castelo, na cidade de Viana do Castelo.
\item ii) Serviço código sv002, descrição "Maternidade", na instituição Hospital de Viana do Castelo, na cidade de Viana do Castelo.
\item iii) Serviço código sv003, descrição "Urgência", na instituição Hospital de Matosinhos, na cidade de Matosinhos.
\end{itemize}

seriam traduzidos logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 servico(sv001,cardiologia,hospital_viana_castelo,viana_castelo).
 servico(sv002,maternidade,hospital_viana_castelo,viana_castelo).
 servico(sv003,urgencia,hospital_matosinhos,matosinhos).
\end{lstlisting}

%%%%%%%%%%%%
% INCERTO
%%%%%%%%%%%%

\subsubsection{\textbf{Situações de conhecimento imperfeito incerto:}}

Por forma a representarmos conhecimento \textbf{imperfeito incerto}, identificam-se situações anómalas à informação negativa via \textbf{exceções}.\par 
Nestas expressões, considerando X como uma sequência de variáveis $X_{1}$,$X_{2}$, ...,$X_{n}$, em que n é o número de argumentos do predicado \textbf{servico}, então $v_{i}$ representa a mesma sequência , mas na qual se substitui $X_{j}$ pelo valor nulo específico v.\par No caso do predicado utente, foi incluído no corpo da formalização lógica a exceção, tal como visto anteriormente na secção \ref{pred_servico}.\par 

Assim, o enunciado: 
\begin{itemize}
\item i) Foi adicionada à instituição Hospital de Viana do Castelo , na cidade de Viana do Castelo, um novo serviço de código IdServ sv008. Contudo, a descrição do novo serviço é ainda desconhecida de momento.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 servico(sv008,imperfeito_incerto_3,hospital_viana_castelo,viana_castelo).
 
 excecao(servico(IdServ, Descricao, Instituicao, Cidade)) :- utente(IdServ, Descricao, imperfeito_incerto3, Cidade).
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito impreciso:}}


        
        %%%%%%%%%%%%
        % IMPRECISO
        %%%%%%%%%%%%
        
Valores nulos do tipo imperfeito impreciso, representam-se, tal como para situações de conhecimento imperfeito incerto, via \textbf{exceções}. Contudo, neste caso os valores atómicos nulos específicos concretizam explicitamente todas as possibilidades de representação dos valores nulos. Neste caso restringimos as situações de desconhecimento de informação.\par 


Assim, o enunciado: 
\begin{itemize}
\item i) Sabe-se que o novo serviço, de código IdServ sv009, na Instituição Hospital de São Marcos, na cidade de Braga, é de Cardiologia ou Geriatria.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 excecao(servico(sv009,cardiologia,hospital_sao_marcos,braga)).
 excecao(servico(sv009,geriatria,hospital_sao_marcos,braga)).
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito interdito:}}

        %%%%%%%%%%%%
        % INTERDITO
        %%%%%%%%%%%%
Tal como verificado nas subsecções anteriores, representa-se um valor nulo $n_{i}$ do tipo não permitido via \textbf{exceções}. Nestes casos temos ainda a necessidade de garantir a não permissão de qualquer atualização a este tipo de valores, explicitando o valor nulo,
a confirmar pela aplicação de uma restrição adequadamente construída para o efeito, impedindo a posterior inclusão de valores atómicos que violem a condição imposta pelo valor nulo não permitido.

Assim, o enunciado: 
\begin{itemize}
\item i) Os registos hospitalares em papel, devido a um incêndio, foram perdidos. Sabia-se apenas que o serviço de código sv010, estava localizado no hospital de Matosinhos, na cidade de Matosinhos, pelo que se torna impossível vir a saber a descrição do mesmo.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:


\begin{lstlisting}
 servico(sv010,imperfeito_interdito_2,hospital_matosinhos,matosinhos).
 excecao(servico(IdServ, Descricao, Instituicao, Cidade)) :- servico(IdServ, imperfeito_interdito2, Instituicao, Cidade).
 nulo(imperfeito_interdito2).
 
 +servico(IdServ, Descricao, Instituicao, Cidade)::(
   solucoes( (IdServ,Descricao,Instituicao,Cidade), ( servico(sv010,Descricao,hospital_matosinhos,matosinhos),nao(nulo(Descricao))),S),
   comprimento(S,N),
   N==0
 ).
 \end{lstlisting}   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
              %%%%%%%%%%%%%%%%%
         %%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%
       %%%%%
       %%%%%
       %%%%%  CONSULTA
       %%%%%
       %%%%%
    %%%%%%%%%%%    
    %%%%%%%%%%%    
        %%%%
        %%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%
        
      \subsection{Consulta}
        A informação lógica relevante relativa a consultas médicas, para o nosso exemplo prático, é a sua data, o identificador único do utente envolvido na consulta, o identificador único do serviço onde foi realizada a consulta, assim como o valor pago pela consulta médica. \par 
        De seguida passaremos a especificar e justificar a extensão do predicado consulta, enumerando situações que exemplificam conhecimento positivo e negativo, e casos de conhecimento imperfeito.\par 
        
        \subsubsection{\textbf{Extensão do predicado consulta:}}
        
        A descrição informal do conhecimento sobre consultas médicas pode ser representada através de Programação Lógica Estendida, pela introdução do predicado consulta com quatro argumentos. O primeiro representa a data na qual ocorreu a consulta, o segundo representa identificador único utente, o terceiro o identificador único do serviço, e o quarto representa o valor pago pelo utente.\par 
        
Para representar corretamente esta informação, \textbf{incluindo situações de exceção}, torna-se necessária uma formalização adequada  numa linguagem que permita tratar valores nulos. \par
Precisamos ainda de fazer uso da \texbf{negação explícita (em conjunto com a implícita)}, para formalizar a descrição de informação.\par 
Temos assim a possibilidade de representar situações de conhecimento perfeito positivo e negativo, incluindo ainda situações de exceção que iremos discutir posteriormente. Atente na transposição para PLE:\par 
\subsubsection{\textbf{Situações de conhecimento perfeito positivo e negativo:}}
\label{pred_consulta}
\begin{lstlisting}
 % Extensao do predicado consulta: Data, IdUt, IdServ, Custo -> {V,F,D}
 
 -consulta(Data, IdUt, IdServ, Custo) :- nao(consulta(Data, IdUt, IdServ, Custo)),
                                         nao(excecao(consulta(Data, IdUt, IdServ, Custo))).
\end{lstlisting}

Assim, os enunciados: 
\begin{itemize}
\item i) Consulta médica, com data de ocorrência 23-04-2016, envolveu o utente com identificador único ut001, no serviço com identificador único sv001, com um custo de 10 unidades monetárias para o utente.
\item ii) Consulta médica, com data de ocorrência 19-12-1990, envolveu o utente com identificador único ut002, no serviço com identificador único sv003, com um custo de 0 unidades monetárias para o utente.
\end{itemize}

seriam traduzidos logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 consulta(23-04-2016,ut001,sv001,10).
 consulta(19-12-1990,ut002,sv003,0).
\end{lstlisting}

%%%%%%%%%%%%
% INCERTO
%%%%%%%%%%%%

\subsubsection{\textbf{Situações de conhecimento imperfeito incerto:}}

Por forma a representarmos conhecimento \textbf{imperfeito incerto}, identificam-se situações anómalas à informação negativa via \textbf{exceções}.\par 
Nestas expressões, considerando X como uma sequência de variáveis $X_{1}$,$X_{2}$, ...,$X_{n}$, em que n é o número de argumentos do predicado \textbf{consulta}, então $v_{i}$ representa a mesma sequência , mas na qual se substitui $X_{j}$ pelo valor nulo específico v.\par No caso do predicado utente, foi incluído no corpo da formalização lógica a exceção, tal como visto anteriormente na secção \ref{pred_consulta}.\par 

Assim, o enunciado: 
\begin{itemize}
\item i) Foi realizada uma intervenção médica urgente num utente que havia dado entrada acompanhado pela polícia, no dia 25-04-2016,
no serviço hospitalar de código sv004. A consulta médica teve um custo de 200 unidades monetárias. A identificação do indivíduo é ainda desconhecida de momento.

.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 consulta(25-04-2016,imperfeito_incerto4,sv004,200).
 
 excecao(consulta(Data,IdUt,IdServ,Custo)) :- consulta(Data, imperfeito_incerto4, IdServ,Custo).
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito impreciso:}}


        
        %%%%%%%%%%%%
        % IMPRECISO
        %%%%%%%%%%%%
        
Valores nulos do tipo imperfeito impreciso, representam-se, tal como para situações de conhecimento imperfeito incerto, via \textbf{exceções}. Contudo, neste caso os valores atómicos nulos específicos concretizam explicitamente todas as possibilidades de representação dos valores nulos. Neste caso restringimos as situações de desconhecimento de informação.\par 


Assim, o enunciado: 
\begin{itemize}
\item i) Sabe-se que o utente de código ut001, no serviço sv009, teve uma consulta ou no dia 24-05-2016, ou no dia 25-05-2016, tendo a consulta tido um custo de 100 unidades monetárias.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:
\begin{lstlisting}
 excecao(consulta(24-05-2016,ut001,sv009,100)).
 excecao(consulta(25-05-2016,ut001,sv009,100)).
\end{lstlisting}

\subsubsection{\textbf{Situações de conhecimento imperfeito interdito:}}

        %%%%%%%%%%%%
        % INTERDITO
        %%%%%%%%%%%%
Tal como verificado nas subsecções anteriores, representa-se um valor nulo $n_{i}$ do tipo não permitido via \textbf{exceções}. Nestes casos temos ainda a necessidade de garantir a não permissão de qualquer atualização a este tipo de valores, explicitando o valor nulo,
a confirmar pela aplicação de uma restrição adequadamente construída para o efeito, impedindo a posterior inclusão de valores atómicos que violem a condição imposta pelo valor nulo não permitido.

Assim, o enunciado: 
\begin{itemize}
\item i) No dia 31-12-2015, foi realizada uma consulta médica, no serviço de código sv010, ao utente ut005. Logo de seguida a secretaria do hospital foi assaltada tendo sido os computadores roubados e a caixa com o dinheiro, pelo que se torna impossível vir a saber o valor pago pela consulta.
\end{itemize}

seria traduzido logicamente  no nosso exemplo prático em:

\begin{lstlisting}
 consulta(31-12-2015,ut005,sv010,imperfeito_interdito_3).
 excecao(consulta(Data,IdUt,IdServ,Custo)) :- consulta(Data,IdIt,IdServ,imperfeito_interdito_3).
 nulo(imperfeito_interdito3).
 
 +consulta(Data,IdUt,IdServ,Custo)::(
   solucoes( (Data,IdUt,IdServ,Custo), ( consulta(31-12-2015,ut005,sv010,Custo),nao(nulo(Custo))),S),
   comprimento(S,N),
   N==0
 ).
 \end{lstlisting}   














     
        
        
        

    \section{Funcionalidades Propostas}
Caracterizado logicamente o universo de discurso, resta-nos elaborar os predicados capazes de responder às funcionalidades obrigatórias propostas. As  secções seguintes descrevem a solução encontrada para cada uma das funcionalidades. \par Em algumas das extensões de predicados irá encontrar o recurso a predicados como \textbf{solucoes(...),removerduplicados(...),...}. Esses mesmos predicados foram desenvolvidos no decorrer das aulas práticas da unidade curricular sendo os mesmos descritos na secção:  \ref{predicados_aux}.\par 
Denote que por forma a ilustrar corretamente todas as funcionalidades do sistema foi desenvolvida um exemplo de base de conhecimento que poderá ser consultado na secção \ref{base_conhecimento_anexo}. Todos os testes são portanto o resultado de cada extensão de predicado a essa mesma base de conhecimento, e serão enumerados graficamente na secção \ref{exemplos_jasper} na página \pageref{exemplos_jasper}, através da componente implementada recorrendo a JAVA e JASPER. \par 
\textbf{Por mera confirmação serão apresentados na secção atual os testes em Sicstus}.\par 







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 1 
%%%
%%%%%%
\subsection{Identificar todas as consultas médicas de um utente}

Foi construída a extensão do predicado \textbf{consultasMedicasUtente(IdUt,ListaEventosMedicos)}, que dado um identificador único de utente, calcula a lista de consultas medicas onde o qual esteve envolvido, sendo as mesmas demonstradas em \textbf{ListaEventosMedicos}.\par 

\begin{lstlisting}
% E1) Extensao do predicado que permite identificar todos as consultas medicas de um utente
 %consultasMedicasUtente(ItUt, ListaEventosMedicos) -> {V,F,D}
 consultasMedicasUtente(IdUt,ListaEventosMedicos) :-
 solucoes( (Data,IdUt,IdServ,Custo), ( consulta(Data,IdUt,IdServ,Custo) ), ListaEventosMedicos).
\end{lstlisting}

%%%
%%%%%% TESTES 1
%%%
\subsubsection{Teste do predicado \textbf{consultasMedicasUtente(IdUt,ListaEventosMedicos)}:}

\begin{lstlisting}
| ?- consultasMedicasUtente(ut001,L).
L = [(23-4-2016,ut001,sv001,10)] ? 
yes
\end{lstlisting}


















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 2
%%%
%%%%%%
\subsection{Calcular o custo de todas as consultas médicas de um utente}





Foi construída a extensão do predicado \textbf{custoConsultasMedicasUtente(IdUt,CustoTotal)}, que dado um identificador único de utente, calcula o custo monetário total das consultas medicas onde o qual esteve envolvido, sendo o mesmo demonstrado em \textbf{CustoTotal}.\par 
\begin{lstlisting}
% E2) Extensao do predicado que permite calcular o custo de todos as consultas medicas de um utente
 %custoConsultasMedicasUtente(ItUt, CustoTotal) -> {V,F,D}
 custoConsultasMedicasUtente(IdUt,CustoTotal) :-(
 solucoes( (Custo), ( consulta(Data,IdUt,IdServ,Custo) ), ListaCustosMedicos),
 somarElementos(ListaCustosMedicos,CustoTotal)
\end{lstlisting}


%%%
%%%%%% TESTES 2
%%%
\subsubsection{Teste do predicado \textbf{custoConsultasMedicasUtente(IdUt,CustoTotal)}:}

\begin{lstlisting}
| ?- custoConsultasMedicasUtente(ut001,C).
C = 10 ? 
yes
\end{lstlisting}

\begin{lstlisting}
| ?- custoConsultasMedicasUtente(ut002,C).
C = 0 ? 
yes
\end{lstlisting}















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 3
%%%
%%%%%%
\subsection{Determinar todos os utentes que recorreram a um serviço}

Foi construída a extensão do predicado \textbf{utentesServico(IdServ,ListaUtentes)}, que dado um serviço calcula os utentes do mesmo, sendo os mesmos demonstrados em \textbf{ListaUtentes}.\par 
\begin{lstlisting}
 % E3) Extensao do predicado Identificar os utentes de um determinado servico
 % utentesServico(Servico,ListaUtentes) -> {V,F,D}
 utentesServico(IdServ,ListaUtentes) :-
 solucoes(X, recorreuServico(X, Servico), ListaUtentesRep),
 removerduplicados(ListaUtentesRep,ListaUtentes).
\end{lstlisting}



%%%
%%%%%% TESTES 3
%%%
\subsubsection{Teste do predicado \textbf{utentesServico(IdServ,ListaUtentes)}:}

\begin{lstlisting}
| ?- utentesServico(sv002,L).
L = [ut003,ut004] ? 
yes
\end{lstlisting}

\begin{lstlisting}
| ?- utentesServico(sv005,L).
L = [] ? 
yes
\end{lstlisting}




















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 4
%%%
%%%%%%
\subsection{Identificar os serviços que se podem encontrar numa instituição}



Foi construída a extensão do predicado \textbf{servicosInstituicao(Instituicao,ListaServicos)}, que dada uma instituição  calcula os serviços médicos da mesma, sendo estes demonstrados em \textbf{ListaServicos}.\par 
\begin{lstlisting}
 % E4) Extensao do predicado Identificar os servicos existentes numa instituicao
 % servicosInstituicao(Instituicao,ListaServicos) -> {V,F,D}
 servicosInstituicao(Instituicao,ListaServicos) :- solucoes((IdServ,Descricao), servico(IdServ,Descricao,Instituicao,Cidade), ListaServicos).
\end{lstlisting}


%%%
%%%%%% TESTES 4
%%%
\subsubsection{Teste do predicado \textbfservicosInstituicao(Instituicao,ListaServicos)}:}

\begin{lstlisting}
| ?- servicosInstituicao(hospital_sao_marcos,L).
L = [(sv004,maternidade)] ? 
yes
\end{lstlisting}

















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 9
%%%
%%%%%%

\subsection{Alterações à base de conhecimento}
\label{base_conhecimento}
De forma a ser possível mudar a base de conhecimento, utilizando os predicados evolucao (secção \ref{evolucao}) e remocao (secção \ref{remocao}), foi necessário adicionar as seguintes definições iniciais ao prolog:
\begin{lstlisting}
% SICStus PROLOG: Definicoes iniciais

:- op(900,xfy,'::').

:- dynamic utente/4.
:- dynamic servico/4.
:- dynamic consulta/4.
\end{lstlisting}

Contudo, necessitamos ainda de garantir a preservação da correção da base conhecimento em todas as operações de alteração à mesma. Assim, como veremos nas secções seguintes, todas as operações de remoção e adição respeitam os respetivos invariantes estruturais e referenciais definidos.

\subsection{Registar utentes, serviços, ou consultas no sistema}
\label{evolucao}

\subsubsection{Invariantes para operações de adição}
\label{invariantes_adicao}
Tal como referido na secção \ref{base_conhecimento} é necessário preservar a correção da base de conhecimento. Ora, para as operações de adição de conhecimento necessitamos de garantir:
\begin{itemize}

%%%%%%%%% UTENTE
\item   utente:
\begin{itemize}
\item        Invariante Estrutural:
\begin{itemize}
\item           utentes distintos não têm o mesmo IdUt;
\end{itemize}
\end{itemize}

traduzido logicamente para:
\begin{lstlisting}
 +utente(IdUt,Nome,Idade,Morada)::(
   solucoes( (IdUt), ( utente(IdUt,_,_,_) ), Lista),
   comprimento(Lista,N),
   N==1
 ).
\end{lstlisting}



%%%%%%%%% SERVIÇO
\item   serviço:
\begin{itemize}
\item        Invariante Estrutural:
\begin{itemize}
\item         serviços distintos não têm o mesmo IdServ;
\end{itemize}
\end{itemize}
traduzido logicamente para:
\begin{lstlisting}
 +servico(Servico,Descricao,Instituicao,Cidade)::(
   solucoes( (Servico) , ( servico(Servico,_,_,_) ), Lista),
   comprimento(Lista,N),
   N==1
 ).
\end{lstlisting}


%%%%%%%%% CONSULTA
\item   registo:
\begin{itemize}
\item        Invariante Estrutural:
\begin{itemize}
\item         tem que existir pelo menos uma consulta com essas características depois da inserção;
\end{itemize}
\item        Invariante Referencial:
\begin{itemize}
\item         o utente associado à consulta existe;
\item         o serviço associado à consulta existe;
\item 	o profissional associado ao registo está associado ao serviço e instituição;
\end{itemize}
\end{itemize}
traduzido logicamente para:
\begin{lstlisting}
 +consulta(Data,IdUtente,IdServico,Custo)::(
   solucoes( (Data,IdUtente,IdServico,Custo), ( consulta(Data,IdUtente,IdServico,Custo) ), Lista),
   comprimento(Lista,N),
   N>=1,
   solucoes( (IdUtente), ( utente(IdUtente,_,_,_) ), ListaUten),
   comprimento(ListaUten,NUten),
   NUten==1,
   solucoes( (IdServico) , ( servico(IdServico,_,_,_ ) ), ListaServ),
   comprimento(ListaServ,NServ),
   NServ==1
 ).
\end{lstlisting}

\end{itemize}
\subsubsection{Predicados para operações de adição}
Definidos os invariantes para as operações de adição à base de conhecimento, resta-nos definir as extensões de predicados que permitem registar utentes, serviços, e consultas médicas.\par
Denote que as extensões de predicados seguidamente definidas recorrem ao predicado \textbf{evolucao(Termo)}, definido durante as aulas práticas da unidade curricular e possível de ser consultado na secção \ref{evolucao_anexo}.

\begin{lstlisting}
% E5) Extensao do predicado Registar utentes, serviços, ou consultas

% Extensao do predicado que pemite registar utentes
% registarUtente(IdUt,Nome,Idade,Morada) -> {V,F,D}
registarUtente(IdUt,Nome,Idade,Morada) :- evolucao(utente(IdUt,Nome,Idade,Morada)).
-registarUtente(IdUt,Nome,Idade,Morada) :- nao(evolucao(utente(IdUt,Nome,Idade,Morada))).

% Extensao do predicado que pemite registar servicos numa instituicao
% registarServico(IdServ,Descricao, Instituicao, Cidade ) -> {V,F,D}
registarServico(IdServ,Descricao,Instituicao,Cidade) :- (evolucao(servico(IdServ,Descricao,Instituicao,Cidade))).
-registarServico(IdServ,Descricao,Instituicao,Cidade) :- nao(evolucao(servico(IdServ,Descricao,Instituicao,Cidade))).

% Extensao do predicado que pemite registar consultas medicas, indicando a data, a identificacao do utente, do servico,
% numa instituicao indicando o utente, o profissional, o servico e a instituicao
% registarConsulta(Data,IdUt,IdServ,Custo) -> {V,F,D}
registarConsulta(Data,IdUt,IdServ,Custo) :- evolucao(consulta(Data,IdUt,IdServ,Custo)).
-registarConsulta(Data,IdUt,IdServ,Custo) :- nao(evolucao(consulta(Data,IdUt,IdServ,Custo))).
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%%% 10
%%%
%%%%%%
\subsection{Remover utentes, ou serviços, ou consultas do sistema}
\label{remocao}

\subsubsection{Invariantes para operações de remoção}
\label{invariantes_remocao}

Tal como referido na secção \ref{base_conhecimento} é necessário preservar a correção da base de conhecimento. Ora, para as operações de remoção de conhecimento necessitamos de garantir:
\begin{itemize}

%%%%%%%%% UTENTE
\item   utente:
\begin{itemize}
\item        Invariante Estrutural:
\begin{itemize}
\item           não pode existir o utente depois da operação de remoção;
\end{itemize}
\item        Invariante Referencial:
\begin{itemize}
\item         utentes apenas podem ser eliminado se não existirem consultas a ele associado;
\end{itemize}

\end{itemize}

traduzido logicamente para:
\begin{lstlisting}
 -utente(IdUtente,Nome,Idade,Morada)::(
   solucoes( (IdUtente), ( utente(IdUtente,Nome,Idade,Morada) ), Lista),
   comprimento(Lista,N),
   N==0,
   solucoes( (_,IdUtente,_,_), ( consulta(Data,IdUtente,_,_) ), ListaCons),
   comprimento(ListaCons,NCons),
   NCons==0
 ).
\end{lstlisting}



%%%%%%%%% SERVIÇO

%   - servico:
%        Invariante Estrutural:
%           - nao pode existir o servico depois da operacao de remocao.
%        Invariante Referencial:
%           - servicos apenas podem ser eliminados se nao exitirem registos a ele associados
%           - servicos apenas podem ser eliminados se nao exitirem profissionais a ele associados

\item   serviço:
\begin{itemize}
\item        Invariante Estrutural:
\begin{itemize}
\item         não pode existir o serviço depois da operação de remoção;
\end{itemize}
\item        Invariante Referencial:
\begin{itemize}
\item         serviços apenas podem ser eliminados se não existirem consultas médicas a eles associados;
\end{itemize}
\end{itemize}
traduzido logicamente para:
\begin{lstlisting}
 -servico(IdServico,Descricao,Instituicao,Cidade)::(
   solucoes( (IdServico) , ( servico(IdServico,_,_,_) ), Lista),
   comprimento(Lista,N),
   N==0,
   solucoes( (Dat,IdUtente,IdServico,Custo), ( consulta(Data,IdUtente,IdServico,Custo) ), ListaCons),
   comprimento(ListaCons,NCons),
   NCons==0
 ).
\end{lstlisting}


\end{itemize}
\subsubsection{Predicados para operações de remoção}
Definidos os invariantes para as operações de remoção à base de conhecimento, resta-nos definir as extensões de predicados que permitem remover utentes, serviços e consultas.\par
Denote que as extensões de predicados seguidamente definidas recorrem ao predicado \textbf{remocao(Termo)}, analogamente inverso ao predicado  \textbf{evolucao(Termo)} e possível de ser consultado na seção \ref{remocao_anexo}.

\begin{lstlisting}
 % E6) Remover utentes, ou servicos,  ou consultas do sistema de reprensentacao

% Extensao do predicado que pemite remover utentes
% removerUtente(IdUt,Nome,Idade,Morada) -> {V,F,D}
removerUtente(IdUt,Nome,Idade,Morada) :- remocao(utente(IdUt,Nome,Idade,Morada)).
-removerUtente(IdUt,Nome,Idade,Morada) :- nao(remocao(utente(IdUt,Nome,Idade,Morada))).

% Extensao do predicado que pemite remover servicos
% removerServico(IdServ,Descricao, Instituicao, Cidade ) -> {V,F,D}
removerServico(IdServ,Descricao,Instituicao,Cidade) :- evolucao(servico(IdServ,Descricao,Instituicao,Cidade)).
-removerServico(IdServ,Descricao,Instituicao,Cidade) :- nao(evolucao(servico(IdServ,Descricao,Instituicao,Cidade))).

% Extensao do predicado que pemite remover consultas medicas, indicando a data, a identificacao do utente, do servico,
% numa instituicao indicando o utente, o profissional, o servico e a instituicao
% removerConsulta(Data,IdUt,IdServ,Custo) -> {V,F,D}
removerConsulta(Data,IdUt,IdServ,Custo) :- remocao(consulta(Data,IdUt,IdServ,Custo)).
-removerConsulta(Data,IdUt,IdServ,Custo) :- nao(remocao(consulta(Data,IdUt,IdServ,Custo))).
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
%
%
%%%%%%%% EXTRA 
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Componente JAVA e JASPER}
A interação do utilizador com toda a estrutura criada em PROLOG e subjacente ao motor SICStus será feita com recurso ao JAVA. O elo de comunicação é aqui assegurado pela biblioteca JASPER que se encarrega de converter os sinais enviados pelo JAVA para uma linguagem compreendida pelo SICStus.\par
Existem alternativas para a interoperabilidade com outras linguagens de programação, contudo Jasper é o recomendado para o caso de Java.\par
De facto, a utilização do Jasper revela-se bastante simples. Com uma pequena declaração é possível carregar toda a base de conhecimento sobre serviços, hospitais e utentes para JAVA. Da seguinte forma:\par

\begin{lstlisting}
        SICStus sp;
        sp = new SICStus();
        sp.load("trabalho2");
\end{lstlisting}

\par
Apesar da simplicidade, tal não implica uma menor robustez. Todo o poderio disposto pelo SICStus, está agora disponível para o programar à distância de uma simples query. Basta para tal:
\par

\begin{lstlisting}
    //declaracoes
    SPTerm ListaEventosMedicos;
    HashMap varMap = new HashMap();
    SPQuery query;

    //query
    sp.query("utentesServico(IdUt,ListaEventosMedicos).",varMap);
    ListaEventosMedicos=((SPTerm)varMap.get("ListaEventosMedicos"));
    return ListaEventosMedicos;
\end{lstlisting}


\par
Por forma a comprovar a correção da aplicação a nível lógico, foi criado um conjunto de testes, que verificam todos os pontos enumerados na secção \ref{objectivos} na página \pageref{objectivos}. Em anexo, na secção \ref{java} poderá consultar todo o código necessário para a realização dos mesmos.\par  Enumeram-se de seguida os testes e respetivos outputs esperados e obtidos:

\begin{lstlisting}
###### CONHECIMENTO PERFEITO POSITIVO ######
Teste 1: 	utente("ut001","antonio_sousa","24","rua_de_santo_ovideo");
 	Esperado (verdadeiro) : verdadeiro

###### CONHECIMENTO PERFEITO NEGATIVO ######
Teste 2: 	utente("ut001000","antonio_sousa","24","rua_de_santo_ovideo");
 	Esperado (falso) : falso

###### CONHECIMENTO IMPERFEITO INCERTO ######
Teste 3: 	utente("ut007","sergio_caldas","25","rua_de_santo_ovideo");
 	Esperado (desconhecido) : desconhecido

###### CONHECIMENTO IMPERFEITO IMRECISO ######
Teste 4: 	utente("ut008","luis_mendes","25","rua_das_margaridas");
Teste 4: 	utente("ut008","luis_mendes","20","rua_das_margaridas");
Teste 4: 	utente("ut008","luis_mendes","30","rua_das_margaridas");
 	Esperado (desconhecido) : desconhecido
 	Esperado (falso) : falso
 	Esperado (desconhecido) : desconhecido

###### CONHECIMENTO IMPERFEITO INTERDITO ######
Teste 5: 	utente("ut009","carlos_sa","40","fundacao_abcd");
 	Esperado (desconhecido) : desconhecido
>>>>> Teste 5: 	registarUtente("ut009","carlos_sa","40","fundacao_abcd");
 	Esperado (falso) : falso

###### EVOLUCAO DO CONHECIMENTO E RESTRICOES ######
Teste 6: 	registarUtente("ut100","manuel_alves","40","universidade_minho");
 	Esperado (verdadeiro) : verdadeiro
Teste 6.1(voltar registar): 	registarUtente("ut100","manuel_alves","40","universidade_minho");
 	Esperado (falso) : falso

###### REMOCAO DO CONHECIMENTO E RESTRICOES ######
Teste 7: 	removerUtente("ut002","filipe_oliveira","25","urb_qta_orfaos");
 	Esperado (falso) : falso
Teste 7: 	removerConsulta("19-12-1990","ut002","sv003","0");
 	Esperado (verdadeiro) : verdadeiro
Teste 7(tentar remover novamente):  	removerUtente("ut002","filipe_oliveira","25","urb_qta_orfaos");
 	Esperado (verdadeiro) : verdadeiro

###### FUNCIONALIDADES PROPOSTAS ######

###### QUERIE 1
Teste 8: 	consultasMedicasUtente(ut001,ListaEventosMedicos);
 	ListaEventosMedicos : [,(-(-(23,4),2016),,(ut001,,(sv001,10)))]

###### QUERIE 2
Teste 9: 	custoConsultasMedicasUtente(ut001,CustoTotal);
 	Custo Total : 10 Unidades Monetarias

###### QUERIE 3
Teste 10: 	utentesServico(sv001,ListaUtentes);
 	ListaUtentes : [ut001]

###### QUERIE 4
Teste 11: 	servicosInstituicao(hospital_viana_castelo,ListaServicos);
 	ListaServicos : [,(sv001,cardiologia), ,(sv002,maternidade), ,(sv008,INCERTO)]
\end{lstlisting}




Em adição, do outro lado do plano, do ponto de vista do utilizador final, este poderá ainda interagir com a aplicação em JAVA  mediante a utilização do terminal. Tal abordagem permitirá grande flexibilidade do ponto de vista funcional, o que se traduz num leque alargado de formas de input (questões) e respetivas formas de output (respostas). Tendo em vista um público alvo mais técnico, achou-se por bem seguir esta metodologia.
\par
Passando então à prática, o utilizador pode facilmente "bisbilhotar" a base de conhecimento fazendo uso do seguinte comando:\par

\begin{lstlisting}
trabalho.java <base de conhecimento> <query>
\end{lstlisting}
Alguns exemplos de input possível:
\par
Output esperado:
\par
Como se pode verificar, tal implementação oferecerá um grande grau de liberdade ao utilizador.
\par
Mais exemplos:
\par
\begin{lstlisting}
//Identificar todos as consultas medicas de um utente
trabalho.java ... ... ..
\end{lstlisting}

Ficam assim efetivamente demonstradas as várias potencialidades desta biblioteca JASPER. A partir daqui o céu é o limite. Poderia-se, por exemplo, colocar o PROLOG a correr num servidor distinto, com uma aplicação web em JAVA a funcionar como uma espécie de mediador, o "software glue". O utilizador final, munido de uma simples interface web em bootstrap (por exemplo), teria acesso fácil a toda a informação relativa aos hospitais, serviços e utentes.

\par
	% CHAPTER - Conclusion/Future Work --------------
	\chapter{Conclusão}
	
	
	
	O presente trabalho de grupo, em todas as suas fases teve como principal propósito a familiarização da utilização da linguagem de programação em lógica PROLOG, como forma de conhecimento e construção de
mecanismos de raciocínio para a resolução de problemas. Tal objetivo foi cumprido.\par 
		Apesar do modelo apresentado possuir limitações dada a sua simplicidade, pode concluir-se que garante a correta evolução da base de conhecimento, possibilitando um suporte base sólido para o desenvolvimento de funcionalidades adicionais. 
		O modelo proposto pode servir como um ponto de partida para o 
desenvolvimento de um sistema mais completo, capaz de verdadeiramente auxiliar os gestores de unidades de cuidados de saúde profissionais, assim como na prática clínica por parte dos profissionais.
			
			
	%- Bibliography (needs bibtex) -%
%	\bibliography{dissertation}


	% Index of terms (needs  makeindex) -------------
	%\printindex
	
	
	% APPENDIX --------------------------------------
	\umappendix{Appendix}
		\chapter{Anexos}


\section{Exemplo Prático de Base de Conhecimento}
	\label{base_conhecimento_anexo}
	\begin{lstlisting}	
% -----------------------------------
% Base de Conhecimento sobre Utentes --------------------------------------------------------------------------------------------
% -----------------------------------
% Extensao do predicado utente: IdUt, Nome, Idade, Morada -> {V,F,D}

-utente(IdUt, Nome, Idade, Morada) :- nao(utente(IdUt, Nome, Idade, Morada)),
                                      nao(excecao(utente(IdUt, Nome, Idade, Morada))).

% -------------------------------------------------
% conhecimento perfeito positivo relativo a utentes
% -------------------------------------------------

utente(ut001,antonio_sousa,24,rua_de_santo_ovideo).
utente(ut002,filipe_oliveira,25,urb_qta_orfaos).
utente(ut003,fernando_oliveira,55,rua_gen_humberto_delgado).
utente(ut004,fernanda_oliveira,52,rua_gen_humberto_delgado).
utente(ut005,ricardo_oliveira,27,rua_gen_humberto_delgado).

% -------------------------------------

%   Consideramos que apenas sao permitidas situacoes de conhecimento incerto/impreciso/interdito para os campos Idade e Morada

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito incerto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      O utente filipe marques, de codigo ut006, residente na rua de santo ovideo, tem idade desconhecida no momento
utente(ut006,filipe_marques,imperfeito_incerto1,rua_santo_ovideo).

%      O utente sergio caldas, de codigo ut007, de idade 25 anos, tem residencia desconhecida no momento
utente(ut007,sergio_caldas,25,imperfeito_incerto2).

excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, imperfeito_incerto1, Morada).
excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, Idade, imperfeito_incerto2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito impreciso
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Sabe-se que o utente luis mendes, de codigo ut008, tem idade entre 25 e 30 anos, e residencia na rua das margaridas
excecao(utente(ut008, luis_mendes, IDADE, rua_das_margaridas)) :- IDADE =< 30, IDADE >=25.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conhecimento imperfeito interdito
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      O utente carlos sa, de codigo ut009, mudo, sem documentos, e incapacitado foi encontrado na rua, passando a residir na fundacao abcd,
%      pelo que se torna impossivel vir a saber a idade do mesmo 
utente(ut009, carlos_sa, imperfeito_interdito1, fundacao_abcd).
excecao(utente(IdUt, Nome, Idade, Morada)) :- utente(IdUt, Nome, imperfeito_interdito1, Morada).
nulo(imperfeito_interdito1).

+utente(IdUt,Nome,Idade,Morada)::(
  solucoes( (IdUt,Nome,Idade,Morada), ( utente(ut009,carlos_sa,Idade,fundacao_abcd),nao(nulo(Idade))),S),
  comprimento(S,N),
  N==0
).

% ------------------------------------
% Base de Conhecimento sobre Serviços --------------------------------------------------------------------------------------------
% ------------------------------------
% Extensao do predicado serviço: IdServ, Descrição, Instituição, Cidade -> {V,F,D}

-servico(IdServ, Descricao, Instituicao, Cidade) :- nao(servico(IdServ, Descricao, Instituicao, Cidade)),
                                                    nao(excecao(servico(IdServ, Descricao, Instituicao, Cidade))).

% --------------------------------------------------
% conhecimento perfeito positivo relativo a servicos
% --------------------------------------------------

servico(sv001,cardiologia,hospital_viana_castelo,viana_castelo).
servico(sv002,maternidade,hospital_viana_castelo,viana_castelo).
servico(sv003,maternidade,hospital_matosinhos,matosinhos).
servico(sv004,maternidade,hospital_sao_marcos,braga).
servico(sv005,maternidade,hospital_da_prelada,porto).
servico(sv006,maternidade,hospital_de_sao_joao,porto).
servico(sv007,maternidade,maternidade_julio_dinis,porto).

% -------------------------------------
% Explicitacao das situacoes de excecao
% -------------------------------------
%   Consideramos que apenas sao permitidas situacoes de conhecimento incerto/impreciso/interdito para os campos IdServ, Descricao, Instituicao, Cidade

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito incerto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Foi adicionada a instituicao hospital de viana do castelo , na cidade de viana do castelo, um novo servico de codigo IdServ sv008,
%     contudo, a descricao do novo servico e ainda desconhecida de momento
servico(sv008,imperfeito_incerto_3,hospital_viana_castelo,viana_castelo).

excecao(servico(IdServ, Descricao, Instituicao, Cidade)) :- utente(IdServ, Descricao, imperfeito_incerto3, Cidade).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito impreciso
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Sabe-se que o novo servico, de codigo IdServ sv009, na Instituicao hospital de sao marcos, na cidade de braga, e de cardiologia ou geriatria 
excecao(servico(sv009,cardiologia,hospital_sao_marcos,braga)).
excecao(servico(sv009,geriatria,hospital_sao_marcos,braga)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conhecimento imperfeito interdito
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Os registos hospitalares em papel, devido a um incendio, foram perdidos. sabia-se apenas que o servico de codigo sv010, estava localizado 
%      no hospital de matosinhos, na cidade de matosinhos, pelo que se torna impossivel vir a saber a descricao do mesmo 

servico(sv010,imperfeito_interdito_2,hospital_matosinhos,matosinhos).
excecao(servico(IdServ, Descricao, Instituicao, Cidade)) :- servico(IdServ, imperfeito_interdito2, Instituicao, Cidade).
nulo(imperfeito_interdito2).

+servico(IdServ, Descricao, Instituicao, Cidade)::(
  solucoes( (IdServ,Descricao,Instituicao,Cidade), ( servico(sv010,Descricao,hospital_matosinhos,matosinhos),nao(nulo(Descricao))),S),
  comprimento(S,N),
  N==0
).

% -------------------------------------
% Base de Conhecimento sobre Consultas -------------------------------------------------------------------------------------------
% -------------------------------------
% Extensao do predicado consulta: Data, IdUt, IdServ, Custo -> {V,F,D}

-consulta(Data, IdUt, IdServ, Custo) :- nao(consulta(Data, IdUt, IdServ, Custo)),
                                        nao(excecao(consulta(Data, IdUt, IdServ, Custo))).

% ---------------------------------------------------
% conhecimento perfeito positivo relativo a consultas
% ---------------------------------------------------

consulta(23-04-2016,ut001,sv001,10).
consulta(19-12-1990,ut002,sv003,0).
consulta(18-12-1960,ut003,sv002,0).
consulta(08-08-1963,ut004,sv002,0).
consulta(17-06-1988,ut005,sv006,0).

% -------------------------------------
% Explicitacao das situacoes de excecao
% -------------------------------------
%   Consideramos que apenas sao permitidas situacoes de conhecimento incerto/impreciso/interdito para os campos Data, IdUt, IdServ, Custo 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito incerto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Foi realizada uma intervencao medica urgente num utente que havia dado entrada acompanhado pela policia, no dia 25-04-2016,
%     no servico hospitalar de codigo sv004. a consulta medica teve um custo de 200euros. A identificacao do individuo e ainda desconhecida de momento
consulta(25-04-2016,imperfeito_incerto4,sv004,200).

excecao(consulta(Data,IdUt,IdServ,Custo)) :- consulta(Data, imperfeito_incerto4, IdServ,Custo).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Conhecimento imperfeito impreciso
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Sabe-se que o utente de codigo ut001, no servico sv009, teve uma consulta ou no dia 24-05-2016, ou no dia 25-05-2016, tendo a consulta tido um custo de 100euros
excecao(consulta(24-05-2016,ut001,sv009,100)).
excecao(consulta(25-05-2016,ut001,sv009,100)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conhecimento imperfeito interdito
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      No dia 31-12-2015, foi realizada uma consulta medica, no servico de codigo sv010, ao utente ut005. Logo de seguida a secretaria do hospital foi assaltada
%      tendo sido os computadores roubados e a caixa com o dinheiro, pelo que se torna impossivel vir a saber o valor pago pela consulta 

consulta(31-12-2015,ut005,sv010,imperfeito_interdito_3).
excecao(consulta(Data,IdUt,IdServ,Custo)) :- consulta(Data,IdIt,IdServ,imperfeito_interdito_3).
nulo(imperfeito_interdito3).

+consulta(Data,IdUt,IdServ,Custo)::(
  solucoes( (Data,IdUt,IdServ,Custo), ( consulta(31-12-2015,ut005,sv010,Custo),nao(nulo(Custo))),S),
  comprimento(S,N),
  N==0
).
	\end{lstlisting}	




\section{Extensão do predicados auxiliares}
	\label{predicados_aux}
	\begin{lstlisting}	
% Extensao do meta-predicado nao : Questao -> {V,F}
nao(Questao) :- Questao, !, fail.
nao(_).

% Verifica se elemento existe dentro de uma lista de elementos
pertence(X,[X | _ ]).
pertence(X,[ _ | XS]) :- pertence(X,XS).

% Nr de elementos existentes numa lista 
comprimento([],0).
comprimento([_ | L],R) :- comprimento(L,N),R is N+1.

% Apaga a primeira ocorrencia de um elemento numa lista
apagar(X, [X | XS], XS).
apagar(E, [X | XS], [X | YS]) :- apagar(E, XS, YS).

% Apaga todas as ocorrencias de um elemento numa lista
apagartudo(_, [], []).
apagartudo(X,[X | XS], YS) :- apagartudo(X,XS,YS).
apagartudo(E,[X | XS], [X | YS]) :- apagartudo(E, XS, YS).

% Insere elemento a cabeca da lista, caso ainda nao exista
adicionar(X, L, L) :- pertence(X,L).
adicionar(X, L, [X | L]).

% Concatenacao da lista L1 com lista L2
concatenar([], L2, L2).
concatenar([X | L1], L2, [X | R]) :- concatenar(L1, L2, R).

% Inverte ordem dos elementos de uma lista
inverter([X],[X]).
inverter([X | XS], L2) :- inverter(XS, YS), concatenar(YS,[X],L2).

% Verifica se S e sublista de L
sublista(S,L) :- concatenar(S,_,L).
sublista(S,L) :- concatenar(_,S,L).
sublista(S, [ _ | YS]) :- 
  sublista(S, YS).

% Remove elementos duplicados de uma lista
removerduplicados([],[]).
removerduplicados([H|T],C) :- pertence(H,T), !, removerduplicados(T,C).
removerduplicados([H|T],[H|C]) :- removerduplicados(T,C).

% Subtrai elementos de L1 a L2, produzindo L3
intercepcao([], L, L).
intercepcao([H | Tail], L2, L3) :- apagar(H, L2, R), intercepcao(Tail, R, L3).
\end{lstlisting}

	\section{Extensão do predicado que permite a evolução de conhecimento}
	\label{evolucao_anexo}

\begin{lstlisting}	
% Predicados que permitem evolucao do conhecimento ------------------------------------------------------------------------------

% Extensao do predicado que permite a evolucao do conhecimento
% disponibilizada pelo professor na aula pratica da semana5
evolucao( Termo ):-solucoes(Invariante,+Termo::Invariante,Lista),
inserir(Termo),
testar(Lista).

% predicado disponibilizado pelo professor na semana5
% inserir: T -> {V,F}
inserir(Termo):-assert(Termo).
inserir(Termo):-retract(Termo),!,fail.

% predicado disponibilizado pelo professor na semana5
% testar: Li -> {V,F}.
testar([]).
testar([I|L]):-I,testar(L).

% Extensao do predicado que permite a remocao do conhecimento
% remocao(Termo) -> {V,F}
remocao( Termo ):-solucoes(Invariante,-Termo::Invariante,Lista),
remover(Termo),
testar(Lista).

% remover: T -> {V,F}
remover(Termo):-retract(Termo).
remover(Termo):-assert(Termo),!,fail.

% predicado disponibilizado pelo professor na semana5
% solucoes X,Y,Z -> {V,F}
solucoes(X,Y,Z):-findall(X,Y,Z).

%--------------------------------- - - - - - - - - - -  -  -  -  -   -
% Extensao do meta-predicado demo: Questao,Resposta -> {V,F}

demo( Questao,verdadeiro ) :-
Questao.
demo( Questao, falso ) :-
-Questao.
demo( Questao,desconhecido ) :-
nao( Questao ),
nao( -Questao ).

%--------------------------------- - - - - - - - - - -  -  -  -  -   -
% Extensao do meta-predicado nao: Questao -> {V,F}

nao( Questao ) :-
Questao, !, fail.
nao( Questao ).
\end{lstlisting}

	
	\section{Extensão do predicado que permite a remoção de conhecimento}
	\label{remocao_anexo}
\begin{lstlisting}	
% Extensao do predicado que permite a remocao do conhecimento
% remocao(Termo) -> {V,F}
remocao( Termo ):-solucoes(Invariante,-Termo::Invariante,Lista),
remover(Termo),
testar(Lista).

% remover: T -> {V,F}
remover(Termo):-retract(Termo).
remover(Termo):-assert(Termo),!,fail.
\end{lstlisting}

\newpage

\section{Código Java da Aplicação}
	\label{java}
\begin{lstlisting}	
/*
 * trabalho2.java: Prolog-Java
 */

import se.sics.jasper.*;

import java.util.Arrays;
import java.util.HashMap;

public class trabalho2
{

  public static HashMap utente(String IdUt, String Nome, String Idade, String Morada)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(utente("+IdUt+","+Nome+","+Idade+","+Morada+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap servico(String IdServ, String Descricao, String Instituicao, String Cidade)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(servico("+IdServ+","+Descricao+","+Instituicao+","+Cidade+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap consulta(String Data, String IdUt, String IdServ, String Custo)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(consulta("+Data+","+IdUt+","+IdServ+","+Custo+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap registarUtente(String IdUt, String Nome, String Idade, String Morada)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(registarUtente("+IdUt+","+Nome+","+Idade+","+Morada+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap removerUtente(String IdUt, String Nome, String Idade, String Morada)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(removerUtente("+IdUt+","+Nome+","+Idade+","+Morada+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap registarServico(String IdServ, String Descricao, String Instituicao, String Cidade)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(registarServico("+IdServ+","+Descricao+","+Instituicao+","+Cidade+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap removerServico(String IdServ, String Descricao, String Instituicao, String Cidade)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(removerServico("+IdServ+","+Descricao+","+Instituicao+","+Cidade+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap registarConsulta(String Data, String IdUt, String IdServ, String Custo)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(registarConsulta("+Data+","+IdUt+","+IdServ+","+Custo+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static HashMap removerConsulta(String Data, String IdUt, String IdServ, String Custo)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(removerConsulta("+Data+","+IdUt+","+IdServ+","+Custo+"),Resposta).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }


  /* 
   * E1) Extensao do predicado que permite identificar todos as consultas medicas de um utente
   * %consultasMedicasUtente(ItUt, ListaEventosMedicos)
   */
  public static HashMap querie1(String IdUt)
  {
    SICStus sp;
    HashMap varMap = new HashMap();
    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(consultasMedicasUtente("+IdUt+",ListaEventosMedicos),Resultado).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  /* 
   *  % E2) Extensao do predicado que permite calcular o custo de todos as consultas medicas de um utente
   *  %custoConsultasMedicasUtente(ItUt, CustoTotal) -> {V,F,D}
   *  custoConsultasMedicasUtente(IdUt,CustoTotal) :-(
   *   solucoes( (Custo), ( consulta(Data,IdUt,IdServ,Custo) ), ListaCustosMedicos),
   *   somarElementos(ListaCustosMedicos,CustoTotal) 
   *   ).
   */

  public static HashMap querie2(String IdUt)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(custoConsultasMedicasUtente("+IdUt+",CustoTotal),Resultado).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }

    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  /* 
   *  % E3) Extensao do predicado Identificar os utentes de um determinado servico
   *  % utentesServico(IdServ,ListaUtentes) -> {V,F,D}
   *  utentesServico(IdServ,ListaUtentes) :-
   *  solucoes(X, recorreuServico(X, IdServ), ListaUtentesRep),
   *  removerduplicados(ListaUtentesRep,ListaUtentes).
   */

  public  static HashMap querie3(String IdServ)
  {
    SICStus sp;
    SPTerm Resposta = null;

    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(utentesServico("+IdServ+",ListaUtentes),Resposta).", varMap)){
        System.out.println("ERRO: falha na conexão SICSTUS");
      }
    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  /* 
   *  % E4) Extensao do predicado Identificar os servicos existentes numa instituicao
   *  % servicosInstituicao(Instituicao,ListaServicos) -> {V,F,D}
   *  servicosInstituicao(Instituicao,ListaServicos) :- solucoes((IdServ,Descricao), servico(IdServ,Descricao,Instituicao,Cidade), ListaServicos).
   */

  public static HashMap querie4(String Instituicao)
  {
    SICStus sp;
    HashMap varMap = new HashMap();

    try {
      if (null == (sp = SICStus.getInitializedSICStus())) {
        sp = new SICStus();
        sp.load("trabalho2");
      }

      if (!sp.query("demo(servicosInstituicao("+Instituicao+",ListaServicos),Resultado).", varMap))
      {
        System.out.println("ERRO: falha na conexão SICSTUS");
      }

    } catch ( Exception e ) {
      e.printStackTrace();
    }
    return varMap;
  }

  public static String preparaExcecoes(String entrada){
    String saida = entrada;
    saida = saida.replace("imperfeito_interdito_1", "INTERDITO");
    saida = saida.replace("imperfeito_interdito_2", "INTERDITO");
    saida = saida.replace("imperfeito_interdito_3", "INTERDITO");
    saida = saida.replace("imperfeito_incerto_1", "INCERTO");
    saida = saida.replace("imperfeito_incerto_2", "INCERTO");
    saida = saida.replace("imperfeito_incerto_3", "INCERTO");
    saida = saida.replace("imperfeito_incerto_4", "INCERTO");
    return saida;
  }



  public static void main(String argv[]) throws ConversionFailedException, IllegalTermException
  {

    System.out.println("###### CONHECIMENTO PERFEITO POSITIVO ######");
    HashMap utente_perfeito_positivo = utente("ut001","antonio_sousa","24","rua_de_santo_ovideo");
    SPTerm resultado_utente_perfeito_positivo =   (SPTerm) utente_perfeito_positivo.get("Resposta");
    System.out.println("Teste 1: \tutente(\"ut001\",\"antonio_sousa\",\"24\",\"rua_de_santo_ovideo\");");
    System.out.println(" \tEsperado (verdadeiro) : " + resultado_utente_perfeito_positivo.toString());


    System.out.println("\n###### CONHECIMENTO PERFEITO NEGATIVO ######");
    HashMap utente_perfeito_negativo = utente("ut001000","antonio_sousa","24","rua_de_santo_ovideo");
    SPTerm resultado_utente_perfeito_negativo =   (SPTerm) utente_perfeito_negativo.get("Resposta");
    System.out.println("Teste 2: \tutente(\"ut001000\",\"antonio_sousa\",\"24\",\"rua_de_santo_ovideo\");");
    System.out.println(" \tEsperado (falso) : " + resultado_utente_perfeito_negativo.toString());


    System.out.println("\n###### CONHECIMENTO IMPERFEITO INCERTO ######");
    HashMap utente_incerto = utente("ut007","sergio_caldas","25","rua_de_santo_ovideo");
    SPTerm resultado_utente_incerto =   (SPTerm) utente_incerto.get("Resposta");
    System.out.println("Teste 3: \tutente(\"ut007\",\"sergio_caldas\",\"25\",\"rua_de_santo_ovideo\");");
    System.out.println(" \tEsperado (desconhecido) : " + resultado_utente_incerto.toString());


    System.out.println("\n###### CONHECIMENTO IMPERFEITO IMRECISO ######");
    HashMap utente_impreciso_1 = utente("ut008","luis_mendes","25","rua_das_margaridas");
    HashMap utente_impreciso_2 = utente("ut008","luis_mendes","20","rua_das_margaridas");
    HashMap utente_impreciso_3 = utente("ut008","luis_mendes","30","rua_das_margaridas");

    SPTerm resultado_utente_impreciso_1 = (SPTerm) utente_impreciso_1.get("Resposta");
    SPTerm resultado_utente_impreciso_2 = (SPTerm) utente_impreciso_2.get("Resposta");
    SPTerm resultado_utente_impreciso_3 = (SPTerm) utente_impreciso_3.get("Resposta");

    System.out.println("Teste 4: \tutente(\"ut008\",\"luis_mendes\",\"25\",\"rua_das_margaridas\");");
    System.out.println("Teste 4: \tutente(\"ut008\",\"luis_mendes\",\"20\",\"rua_das_margaridas\");");
    System.out.println("Teste 4: \tutente(\"ut008\",\"luis_mendes\",\"30\",\"rua_das_margaridas\");");

    System.out.println(" \tEsperado (desconhecido) : " + resultado_utente_impreciso_1.toString());
    System.out.println(" \tEsperado (falso) : " + resultado_utente_impreciso_2.toString());
    System.out.println(" \tEsperado (desconhecido) : " + resultado_utente_impreciso_3.toString());

    System.out.println("\n###### CONHECIMENTO IMPERFEITO INTERDITO ######");
    HashMap utente_interdito_1 = utente("ut009" ,"carlos_sa" , "40", "fundacao_abcd" );
    SPTerm resultado_utente_interdito_1 = (SPTerm) utente_interdito_1.get("Resposta");
    System.out.println("Teste 5: \tutente(\"ut009\",\"carlos_sa\",\"40\",\"fundacao_abcd\");");
    System.out.println(" \tEsperado (desconhecido) : " + resultado_utente_interdito_1.toString());
    HashMap utente_interdito_2 = registarUtente("ut009" ,"carlos_sa" , "40", "fundacao_abcd" );
    SPTerm resultado_utente_interdito_2 = (SPTerm) utente_interdito_2.get("Resposta");
    System.out.println(">>>>> Teste 5: \tregistarUtente(\"ut009\",\"carlos_sa\",\"40\",\"fundacao_abcd\");");
    System.out.println(" \tEsperado (falso) : " + resultado_utente_interdito_2.toString());


    System.out.println("\n###### EVOLUÇÃO DO CONHECIMENTO E RESTRIÇÕES ######");
    HashMap registarUtente = registarUtente("ut100" ,"manuel_alves" , "40", "universidade_minho" );
    SPTerm resultado_registarUtente = (SPTerm) registarUtente.get("Resposta");
    System.out.println("Teste 6: \tregistarUtente(\"ut100\",\"manuel_alves\",\"40\",\"universidade_minho\");");
    System.out.println(" \tEsperado (verdadeiro) : " + resultado_registarUtente.toString());
    HashMap registarUtente_1 = registarUtente("ut100" ,"manuel_alves" , "40", "universidade_minho" );
    SPTerm resultado_registarUtente_1 = (SPTerm) registarUtente_1.get("Resposta");
    System.out.println("Teste 6.1(voltar registar): \tregistarUtente(\"ut100\",\"manuel_alves\",\"40\",\"universidade_minho\");");
    System.out.println(" \tEsperado (falso) : " + resultado_registarUtente_1.toString());


    System.out.println("\n###### REMOCAO DO CONHECIMENTO E RESTRIÇÕES ######");
    HashMap removerUtente_1 = removerUtente("ut002" ,"filipe_oliveira" , "25", "urb_qta_orfaos" );
    SPTerm resultado_removerUtente_1 = (SPTerm) removerUtente_1.get("Resposta");
    System.out.println("Teste 7: \tremoverUtente(\"ut002\",\"filipe_oliveira\",\"25\",\"urb_qta_orfaos\");");
    System.out.println(" \tEsperado (falso) : " + resultado_removerUtente_1.toString());


    HashMap removerConsulta = removerConsulta("19-12-1990" ,"ut002" , "sv003", "0" );
    SPTerm resultado_removerConsulta = (SPTerm) removerConsulta.get("Resposta");
    System.out.println("Teste 7: \tremoverConsulta(\"19-12-1990\",\"ut002\",\"sv003\",\"0\");");
    System.out.println(" \tEsperado (verdadeiro) : " + resultado_removerConsulta.toString());


    HashMap removerUtente_2 = removerUtente("ut002" ,"filipe_oliveira" , "25", "urb_qta_orfaos" );
    SPTerm resultado_removerUtente_2 = (SPTerm) removerUtente_2.get("Resposta");
    System.out.println("Teste 7(tentar remover novamente):  \tremoverUtente(\"ut002\",\"filipe_oliveira\",\"25\",\"urb_qta_orfaos\");");
    System.out.println(" \tEsperado (verdadeiro) : " + resultado_removerUtente_2.toString());

    System.out.println("\n###### FUNCIONALIDADES PROPOSTAS ######");
    System.out.println("\n###### QUERIE 1");
    System.out.println("Teste 8: \tconsultasMedicasUtente(ut001,ListaEventosMedicos);");
    HashMap consultasMedicasUtente = querie1("ut001");
    SPTerm resultado_consultasMedicasUtente = (SPTerm) consultasMedicasUtente.get("ListaEventosMedicos");
    SPTerm arrayDeTermos[] = resultado_consultasMedicasUtente.toTermArray();
    System.out.println(" \tListaEventosMedicos : " + preparaExcecoes(Arrays.toString(arrayDeTermos)));

    System.out.println("\n###### QUERIE 2");
    System.out.println("Teste 9: \tcustoConsultasMedicasUtente(ut001,CustoTotal);");
    HashMap custoConsultasMedicasUtente = querie2("ut001");
    SPTerm resultado_custoConsultasMedicasUtente = (SPTerm) custoConsultasMedicasUtente.get("CustoTotal");
    System.out.println(" \tCusto Total : " + resultado_custoConsultasMedicasUtente.toString() + " Unidades Monetárias");


    System.out.println("\n###### QUERIE 3");
    System.out.println("Teste 10: \tutentesServico(sv001,ListaUtentes);");	
    HashMap utentesServico = querie3("sv001");
    SPTerm resultado_utentesServico = (SPTerm) utentesServico.get("ListaUtentes");
    SPTerm arrayDeTermos_1[] = resultado_utentesServico.toTermArray();
    System.out.println(" \tListaUtentes : " + preparaExcecoes(Arrays.toString(arrayDeTermos_1)));

    System.out.println("\n###### QUERIE 4");
    System.out.println("Teste 11: \tservicosInstituicao(hospital_viana_castelo,ListaServicos);");

    HashMap servicosInstituicao = querie4("hospital_viana_castelo");
    SPTerm resultado_servicosInstituicao = (SPTerm) servicosInstituicao.get("ListaServicos");
    SPTerm arrayDeTermos_2[] = resultado_servicosInstituicao.toTermArray();
    System.out.println(" \tListaServicos : " + preparaExcecoes(Arrays.toString(arrayDeTermos_2)));
  }
}
\end{lstlisting}



\end{document}
